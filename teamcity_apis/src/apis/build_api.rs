/*
 * TeamCity REST API
 *
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 2018.1
 * 
 * Generated by: https://openapi-generator.tech
 */


use reqwest;

use crate::apis::ResponseContent;
use super::{Error, configuration};


/// struct for typed errors of method `add_build_vcs_label`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum AddBuildVcsLabelError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `add_log_message_to_build`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum AddLogMessageToBuildError {
    DefaultResponse(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `add_problem_to_build`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum AddProblemToBuildError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `add_tags_to_build`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum AddTagsToBuildError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `add_tags_to_multiple_builds`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum AddTagsToMultipleBuildsError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `delete_build`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DeleteBuildError {
    DefaultResponse(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `delete_build_comment`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DeleteBuildCommentError {
    DefaultResponse(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `delete_multiple_build_comments`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DeleteMultipleBuildCommentsError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `delete_multiple_builds`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DeleteMultipleBuildsError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `download_file_of_build`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DownloadFileOfBuildError {
    DefaultResponse(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `get_aggregated_build_status`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetAggregatedBuildStatusError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `get_aggregated_build_status_icon`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetAggregatedBuildStatusIconError {
    DefaultResponse(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `get_all_builds`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetAllBuildsError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `get_artifact_dependency_changes`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetArtifactDependencyChangesError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `get_artifacts_directory`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetArtifactsDirectoryError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `get_build`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetBuildError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `get_build_actual_parameters`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetBuildActualParametersError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `get_build_field`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetBuildFieldError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `get_build_finish_date`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetBuildFinishDateError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `get_build_number`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetBuildNumberError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `get_build_pin_info`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetBuildPinInfoError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `get_build_problems`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetBuildProblemsError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `get_build_related_issues`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetBuildRelatedIssuesError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `get_build_resolved`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetBuildResolvedError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `get_build_resulting_properties`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetBuildResultingPropertiesError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `get_build_source_file`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetBuildSourceFileError {
    DefaultResponse(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `get_build_statistic_value`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetBuildStatisticValueError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `get_build_statistic_values`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetBuildStatisticValuesError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `get_build_status_icon`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetBuildStatusIconError {
    DefaultResponse(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `get_build_status_text`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetBuildStatusTextError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `get_build_tags`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetBuildTagsError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `get_build_test_occurrences`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetBuildTestOccurrencesError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `get_build_vcs_labels`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetBuildVcsLabelsError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `get_canceled_info`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetCanceledInfoError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `get_file_metadata_of_build`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetFileMetadataOfBuildError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `get_files_list_for_subpath_of_build`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetFilesListForSubpathOfBuildError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `get_files_list_of_build`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetFilesListOfBuildError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `get_multiple_builds`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetMultipleBuildsError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `get_zipped_file_of_build`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetZippedFileOfBuildError {
    DefaultResponse(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `mark_build_as_running`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum MarkBuildAsRunningError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `pin_multiple_builds`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PinMultipleBuildsError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `remove_multiple_build_tags`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum RemoveMultipleBuildTagsError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `reset_build_finish_properties`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ResetBuildFinishPropertiesError {
    DefaultResponse(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `set_build_comment`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum SetBuildCommentError {
    DefaultResponse(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `set_build_finish_date`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum SetBuildFinishDateError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `set_build_number`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum SetBuildNumberError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `set_build_pin_info`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum SetBuildPinInfoError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `set_build_status_text`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum SetBuildStatusTextError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `set_build_tags`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum SetBuildTagsError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `set_finished_time`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum SetFinishedTimeError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `set_multiple_build_comments`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum SetMultipleBuildCommentsError {
    UnknownValue(serde_json::Value),
}


pub async fn add_build_vcs_label(configuration: &configuration::Configuration, build_locator: &str, locator: Option<&str>, fields: Option<&str>, body: Option<&str>) -> Result<crate::models::VcsLabels, Error<AddBuildVcsLabelError>> {

    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/app/rest/builds/{buildLocator}/vcsLabels", configuration.base_path, buildLocator=crate::apis::urlencode(build_locator));
    let mut local_var_req_builder = local_var_client.post(local_var_uri_str.as_str());

    if let Some(ref local_var_str) = locator {
        local_var_req_builder = local_var_req_builder.query(&[("locator", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = fields {
        local_var_req_builder = local_var_req_builder.query(&[("fields", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.json(&body);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<AddBuildVcsLabelError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn add_log_message_to_build(configuration: &configuration::Configuration, build_locator: &str, fields: Option<&str>, body: Option<&str>) -> Result<(), Error<AddLogMessageToBuildError>> {

    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/app/rest/builds/{buildLocator}/log", configuration.base_path, buildLocator=crate::apis::urlencode(build_locator));
    let mut local_var_req_builder = local_var_client.post(local_var_uri_str.as_str());

    if let Some(ref local_var_str) = fields {
        local_var_req_builder = local_var_req_builder.query(&[("fields", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.json(&body);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<AddLogMessageToBuildError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn add_problem_to_build(configuration: &configuration::Configuration, build_locator: &str, fields: Option<&str>, body: Option<&str>) -> Result<crate::models::ProblemOccurrence, Error<AddProblemToBuildError>> {

    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/app/rest/builds/{buildLocator}/problemOccurrences", configuration.base_path, buildLocator=crate::apis::urlencode(build_locator));
    let mut local_var_req_builder = local_var_client.post(local_var_uri_str.as_str());

    if let Some(ref local_var_str) = fields {
        local_var_req_builder = local_var_req_builder.query(&[("fields", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.json(&body);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<AddProblemToBuildError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn add_tags_to_build(configuration: &configuration::Configuration, build_locator: &str, fields: Option<&str>, body: Option<crate::models::Tags>) -> Result<crate::models::Tags, Error<AddTagsToBuildError>> {

    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/app/rest/builds/{buildLocator}/tags", configuration.base_path, buildLocator=crate::apis::urlencode(build_locator));
    let mut local_var_req_builder = local_var_client.post(local_var_uri_str.as_str());

    if let Some(ref local_var_str) = fields {
        local_var_req_builder = local_var_req_builder.query(&[("fields", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.json(&body);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<AddTagsToBuildError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn add_tags_to_multiple_builds(configuration: &configuration::Configuration, build_locator: &str, fields: Option<&str>, body: Option<crate::models::Tags>) -> Result<crate::models::MultipleOperationResult, Error<AddTagsToMultipleBuildsError>> {

    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/app/rest/builds/multiple/{buildLocator}/tags", configuration.base_path, buildLocator=crate::apis::urlencode(build_locator));
    let mut local_var_req_builder = local_var_client.post(local_var_uri_str.as_str());

    if let Some(ref local_var_str) = fields {
        local_var_req_builder = local_var_req_builder.query(&[("fields", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.json(&body);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<AddTagsToMultipleBuildsError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn delete_build(configuration: &configuration::Configuration, build_locator: &str) -> Result<(), Error<DeleteBuildError>> {

    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/app/rest/builds/{buildLocator}", configuration.base_path, buildLocator=crate::apis::urlencode(build_locator));
    let mut local_var_req_builder = local_var_client.delete(local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<DeleteBuildError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn delete_build_comment(configuration: &configuration::Configuration, build_locator: &str) -> Result<(), Error<DeleteBuildCommentError>> {

    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/app/rest/builds/{buildLocator}/comment", configuration.base_path, buildLocator=crate::apis::urlencode(build_locator));
    let mut local_var_req_builder = local_var_client.delete(local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<DeleteBuildCommentError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn delete_multiple_build_comments(configuration: &configuration::Configuration, build_locator: &str, fields: Option<&str>) -> Result<crate::models::MultipleOperationResult, Error<DeleteMultipleBuildCommentsError>> {

    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/app/rest/builds/multiple/{buildLocator}/comment", configuration.base_path, buildLocator=crate::apis::urlencode(build_locator));
    let mut local_var_req_builder = local_var_client.delete(local_var_uri_str.as_str());

    if let Some(ref local_var_str) = fields {
        local_var_req_builder = local_var_req_builder.query(&[("fields", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<DeleteMultipleBuildCommentsError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn delete_multiple_builds(configuration: &configuration::Configuration, build_locator: &str, fields: Option<&str>) -> Result<crate::models::MultipleOperationResult, Error<DeleteMultipleBuildsError>> {

    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/app/rest/builds/multiple/{buildLocator}", configuration.base_path, buildLocator=crate::apis::urlencode(build_locator));
    let mut local_var_req_builder = local_var_client.delete(local_var_uri_str.as_str());

    if let Some(ref local_var_str) = fields {
        local_var_req_builder = local_var_req_builder.query(&[("fields", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<DeleteMultipleBuildsError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn download_file_of_build(configuration: &configuration::Configuration, path: &str, build_locator: &str, resolve_parameters: Option<bool>, log_build_usage: Option<bool>) -> Result<(), Error<DownloadFileOfBuildError>> {

    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/app/rest/builds/{buildLocator}/artifacts/files{path}", configuration.base_path, path=crate::apis::urlencode(path), buildLocator=crate::apis::urlencode(build_locator));
    let mut local_var_req_builder = local_var_client.get(local_var_uri_str.as_str());

    if let Some(ref local_var_str) = resolve_parameters {
        local_var_req_builder = local_var_req_builder.query(&[("resolveParameters", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = log_build_usage {
        local_var_req_builder = local_var_req_builder.query(&[("logBuildUsage", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<DownloadFileOfBuildError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn get_aggregated_build_status(configuration: &configuration::Configuration, build_locator: &str) -> Result<String, Error<GetAggregatedBuildStatusError>> {

    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/app/rest/builds/aggregated/{buildLocator}/status", configuration.base_path, buildLocator=crate::apis::urlencode(build_locator));
    let mut local_var_req_builder = local_var_client.get(local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<GetAggregatedBuildStatusError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn get_aggregated_build_status_icon(configuration: &configuration::Configuration, build_locator: &str, suffix: &str) -> Result<(), Error<GetAggregatedBuildStatusIconError>> {

    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/app/rest/builds/aggregated/{buildLocator}/statusIcon{suffix}", configuration.base_path, buildLocator=crate::apis::urlencode(build_locator), suffix=crate::apis::urlencode(suffix));
    let mut local_var_req_builder = local_var_client.get(local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<GetAggregatedBuildStatusIconError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn get_all_builds(configuration: &configuration::Configuration, locator: Option<&str>, fields: Option<&str>) -> Result<crate::models::Builds, Error<GetAllBuildsError>> {

    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/app/rest/builds", configuration.base_path);
    let mut local_var_req_builder = local_var_client.get(local_var_uri_str.as_str());

    if let Some(ref local_var_str) = locator {
        local_var_req_builder = local_var_req_builder.query(&[("locator", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = fields {
        local_var_req_builder = local_var_req_builder.query(&[("fields", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<GetAllBuildsError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn get_artifact_dependency_changes(configuration: &configuration::Configuration, build_locator: &str, fields: Option<&str>) -> Result<crate::models::BuildChanges, Error<GetArtifactDependencyChangesError>> {

    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/app/rest/builds/{buildLocator}/artifactDependencyChanges", configuration.base_path, buildLocator=crate::apis::urlencode(build_locator));
    let mut local_var_req_builder = local_var_client.get(local_var_uri_str.as_str());

    if let Some(ref local_var_str) = fields {
        local_var_req_builder = local_var_req_builder.query(&[("fields", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<GetArtifactDependencyChangesError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn get_artifacts_directory(configuration: &configuration::Configuration, build_locator: &str) -> Result<String, Error<GetArtifactsDirectoryError>> {

    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/app/rest/builds/{buildLocator}/artifactsDirectory", configuration.base_path, buildLocator=crate::apis::urlencode(build_locator));
    let mut local_var_req_builder = local_var_client.get(local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<GetArtifactsDirectoryError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn get_build(configuration: &configuration::Configuration, build_locator: &str, fields: Option<&str>) -> Result<crate::models::Build, Error<GetBuildError>> {

    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/app/rest/builds/{buildLocator}", configuration.base_path, buildLocator=crate::apis::urlencode(build_locator));
    let mut local_var_req_builder = local_var_client.get(local_var_uri_str.as_str());

    if let Some(ref local_var_str) = fields {
        local_var_req_builder = local_var_req_builder.query(&[("fields", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<GetBuildError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn get_build_actual_parameters(configuration: &configuration::Configuration, build_locator: &str, fields: Option<&str>) -> Result<crate::models::Properties, Error<GetBuildActualParametersError>> {

    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/app/rest/builds/{buildLocator}/resulting-properties", configuration.base_path, buildLocator=crate::apis::urlencode(build_locator));
    let mut local_var_req_builder = local_var_client.get(local_var_uri_str.as_str());

    if let Some(ref local_var_str) = fields {
        local_var_req_builder = local_var_req_builder.query(&[("fields", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<GetBuildActualParametersError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn get_build_field(configuration: &configuration::Configuration, build_locator: &str, field: &str) -> Result<String, Error<GetBuildFieldError>> {

    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/app/rest/builds/{buildLocator}/{field}", configuration.base_path, buildLocator=crate::apis::urlencode(build_locator), field=crate::apis::urlencode(field));
    let mut local_var_req_builder = local_var_client.get(local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<GetBuildFieldError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn get_build_finish_date(configuration: &configuration::Configuration, build_locator: &str) -> Result<String, Error<GetBuildFinishDateError>> {

    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/app/rest/builds/{buildLocator}/finishDate", configuration.base_path, buildLocator=crate::apis::urlencode(build_locator));
    let mut local_var_req_builder = local_var_client.get(local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<GetBuildFinishDateError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn get_build_number(configuration: &configuration::Configuration, build_locator: &str) -> Result<String, Error<GetBuildNumberError>> {

    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/app/rest/builds/{buildLocator}/number", configuration.base_path, buildLocator=crate::apis::urlencode(build_locator));
    let mut local_var_req_builder = local_var_client.get(local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<GetBuildNumberError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn get_build_pin_info(configuration: &configuration::Configuration, build_locator: &str, fields: Option<&str>) -> Result<crate::models::PinInfo, Error<GetBuildPinInfoError>> {

    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/app/rest/builds/{buildLocator}/pinInfo", configuration.base_path, buildLocator=crate::apis::urlencode(build_locator));
    let mut local_var_req_builder = local_var_client.get(local_var_uri_str.as_str());

    if let Some(ref local_var_str) = fields {
        local_var_req_builder = local_var_req_builder.query(&[("fields", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<GetBuildPinInfoError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn get_build_problems(configuration: &configuration::Configuration, build_locator: &str, fields: Option<&str>) -> Result<crate::models::ProblemOccurrences, Error<GetBuildProblemsError>> {

    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/app/rest/builds/{buildLocator}/problemOccurrences", configuration.base_path, buildLocator=crate::apis::urlencode(build_locator));
    let mut local_var_req_builder = local_var_client.get(local_var_uri_str.as_str());

    if let Some(ref local_var_str) = fields {
        local_var_req_builder = local_var_req_builder.query(&[("fields", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<GetBuildProblemsError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn get_build_related_issues(configuration: &configuration::Configuration, build_locator: &str, fields: Option<&str>) -> Result<crate::models::IssuesUsages, Error<GetBuildRelatedIssuesError>> {

    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/app/rest/builds/{buildLocator}/relatedIssues", configuration.base_path, buildLocator=crate::apis::urlencode(build_locator));
    let mut local_var_req_builder = local_var_client.get(local_var_uri_str.as_str());

    if let Some(ref local_var_str) = fields {
        local_var_req_builder = local_var_req_builder.query(&[("fields", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<GetBuildRelatedIssuesError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn get_build_resolved(configuration: &configuration::Configuration, build_locator: &str, value: &str) -> Result<String, Error<GetBuildResolvedError>> {

    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/app/rest/builds/{buildLocator}/resolved/{value}", configuration.base_path, buildLocator=crate::apis::urlencode(build_locator), value=crate::apis::urlencode(value));
    let mut local_var_req_builder = local_var_client.get(local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<GetBuildResolvedError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn get_build_resulting_properties(configuration: &configuration::Configuration, build_locator: &str, property_name: &str) -> Result<String, Error<GetBuildResultingPropertiesError>> {

    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/app/rest/builds/{buildLocator}/resulting-properties/{propertyName}", configuration.base_path, buildLocator=crate::apis::urlencode(build_locator), propertyName=crate::apis::urlencode(property_name));
    let mut local_var_req_builder = local_var_client.get(local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<GetBuildResultingPropertiesError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn get_build_source_file(configuration: &configuration::Configuration, build_locator: &str, file_name: &str) -> Result<(), Error<GetBuildSourceFileError>> {

    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/app/rest/builds/{buildLocator}/sources/files/{fileName}", configuration.base_path, buildLocator=crate::apis::urlencode(build_locator), fileName=crate::apis::urlencode(file_name));
    let mut local_var_req_builder = local_var_client.get(local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<GetBuildSourceFileError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn get_build_statistic_value(configuration: &configuration::Configuration, build_locator: &str, name: &str) -> Result<String, Error<GetBuildStatisticValueError>> {

    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/app/rest/builds/{buildLocator}/statistics/{name}", configuration.base_path, buildLocator=crate::apis::urlencode(build_locator), name=crate::apis::urlencode(name));
    let mut local_var_req_builder = local_var_client.get(local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<GetBuildStatisticValueError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn get_build_statistic_values(configuration: &configuration::Configuration, build_locator: &str, fields: Option<&str>) -> Result<crate::models::Properties, Error<GetBuildStatisticValuesError>> {

    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/app/rest/builds/{buildLocator}/statistics", configuration.base_path, buildLocator=crate::apis::urlencode(build_locator));
    let mut local_var_req_builder = local_var_client.get(local_var_uri_str.as_str());

    if let Some(ref local_var_str) = fields {
        local_var_req_builder = local_var_req_builder.query(&[("fields", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<GetBuildStatisticValuesError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn get_build_status_icon(configuration: &configuration::Configuration, build_locator: &str, suffix: &str) -> Result<(), Error<GetBuildStatusIconError>> {

    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/app/rest/builds/{buildLocator}/statusIcon{suffix}", configuration.base_path, buildLocator=crate::apis::urlencode(build_locator), suffix=crate::apis::urlencode(suffix));
    let mut local_var_req_builder = local_var_client.get(local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<GetBuildStatusIconError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn get_build_status_text(configuration: &configuration::Configuration, build_locator: &str) -> Result<String, Error<GetBuildStatusTextError>> {

    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/app/rest/builds/{buildLocator}/statusText", configuration.base_path, buildLocator=crate::apis::urlencode(build_locator));
    let mut local_var_req_builder = local_var_client.get(local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<GetBuildStatusTextError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn get_build_tags(configuration: &configuration::Configuration, build_locator: &str, locator: Option<&str>, fields: Option<&str>) -> Result<crate::models::Tags, Error<GetBuildTagsError>> {

    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/app/rest/builds/{buildLocator}/tags", configuration.base_path, buildLocator=crate::apis::urlencode(build_locator));
    let mut local_var_req_builder = local_var_client.get(local_var_uri_str.as_str());

    if let Some(ref local_var_str) = locator {
        local_var_req_builder = local_var_req_builder.query(&[("locator", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = fields {
        local_var_req_builder = local_var_req_builder.query(&[("fields", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<GetBuildTagsError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn get_build_test_occurrences(configuration: &configuration::Configuration, build_locator: &str, fields: Option<&str>) -> Result<crate::models::TestOccurrences, Error<GetBuildTestOccurrencesError>> {

    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/app/rest/builds/{buildLocator}/testOccurrences", configuration.base_path, buildLocator=crate::apis::urlencode(build_locator));
    let mut local_var_req_builder = local_var_client.get(local_var_uri_str.as_str());

    if let Some(ref local_var_str) = fields {
        local_var_req_builder = local_var_req_builder.query(&[("fields", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<GetBuildTestOccurrencesError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn get_build_vcs_labels(configuration: &configuration::Configuration, build_locator: &str, fields: Option<&str>) -> Result<crate::models::VcsLabels, Error<GetBuildVcsLabelsError>> {

    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/app/rest/builds/{buildLocator}/vcsLabels", configuration.base_path, buildLocator=crate::apis::urlencode(build_locator));
    let mut local_var_req_builder = local_var_client.get(local_var_uri_str.as_str());

    if let Some(ref local_var_str) = fields {
        local_var_req_builder = local_var_req_builder.query(&[("fields", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<GetBuildVcsLabelsError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn get_canceled_info(configuration: &configuration::Configuration, build_locator: &str, fields: Option<&str>) -> Result<crate::models::Comment, Error<GetCanceledInfoError>> {

    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/app/rest/builds/{buildLocator}/canceledInfo", configuration.base_path, buildLocator=crate::apis::urlencode(build_locator));
    let mut local_var_req_builder = local_var_client.get(local_var_uri_str.as_str());

    if let Some(ref local_var_str) = fields {
        local_var_req_builder = local_var_req_builder.query(&[("fields", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<GetCanceledInfoError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn get_file_metadata_of_build(configuration: &configuration::Configuration, path: &str, build_locator: &str, fields: Option<&str>, resolve_parameters: Option<bool>, log_build_usage: Option<bool>) -> Result<std::path::PathBuf, Error<GetFileMetadataOfBuildError>> {

    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/app/rest/builds/{buildLocator}/artifacts/metadata{path}", configuration.base_path, path=crate::apis::urlencode(path), buildLocator=crate::apis::urlencode(build_locator));
    let mut local_var_req_builder = local_var_client.get(local_var_uri_str.as_str());

    if let Some(ref local_var_str) = fields {
        local_var_req_builder = local_var_req_builder.query(&[("fields", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = resolve_parameters {
        local_var_req_builder = local_var_req_builder.query(&[("resolveParameters", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = log_build_usage {
        local_var_req_builder = local_var_req_builder.query(&[("logBuildUsage", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<GetFileMetadataOfBuildError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn get_files_list_for_subpath_of_build(configuration: &configuration::Configuration, path: &str, build_locator: &str, base_path: Option<&str>, locator: Option<&str>, fields: Option<&str>, resolve_parameters: Option<bool>, log_build_usage: Option<bool>) -> Result<crate::models::Files, Error<GetFilesListForSubpathOfBuildError>> {

    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/app/rest/builds/{buildLocator}/artifacts/{path}", configuration.base_path, path=crate::apis::urlencode(path), buildLocator=crate::apis::urlencode(build_locator));
    let mut local_var_req_builder = local_var_client.get(local_var_uri_str.as_str());

    if let Some(ref local_var_str) = base_path {
        local_var_req_builder = local_var_req_builder.query(&[("basePath", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = locator {
        local_var_req_builder = local_var_req_builder.query(&[("locator", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = fields {
        local_var_req_builder = local_var_req_builder.query(&[("fields", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = resolve_parameters {
        local_var_req_builder = local_var_req_builder.query(&[("resolveParameters", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = log_build_usage {
        local_var_req_builder = local_var_req_builder.query(&[("logBuildUsage", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<GetFilesListForSubpathOfBuildError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn get_files_list_of_build(configuration: &configuration::Configuration, build_locator: &str, base_path: Option<&str>, locator: Option<&str>, fields: Option<&str>, resolve_parameters: Option<bool>, log_build_usage: Option<bool>) -> Result<crate::models::Files, Error<GetFilesListOfBuildError>> {

    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/app/rest/builds/{buildLocator}/artifacts", configuration.base_path, buildLocator=crate::apis::urlencode(build_locator));
    let mut local_var_req_builder = local_var_client.get(local_var_uri_str.as_str());

    if let Some(ref local_var_str) = base_path {
        local_var_req_builder = local_var_req_builder.query(&[("basePath", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = locator {
        local_var_req_builder = local_var_req_builder.query(&[("locator", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = fields {
        local_var_req_builder = local_var_req_builder.query(&[("fields", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = resolve_parameters {
        local_var_req_builder = local_var_req_builder.query(&[("resolveParameters", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = log_build_usage {
        local_var_req_builder = local_var_req_builder.query(&[("logBuildUsage", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<GetFilesListOfBuildError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn get_multiple_builds(configuration: &configuration::Configuration, build_locator: &str, fields: Option<&str>) -> Result<crate::models::Builds, Error<GetMultipleBuildsError>> {

    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/app/rest/builds/multiple/{buildLocator}", configuration.base_path, buildLocator=crate::apis::urlencode(build_locator));
    let mut local_var_req_builder = local_var_client.get(local_var_uri_str.as_str());

    if let Some(ref local_var_str) = fields {
        local_var_req_builder = local_var_req_builder.query(&[("fields", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<GetMultipleBuildsError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn get_zipped_file_of_build(configuration: &configuration::Configuration, path: &str, build_locator: &str, base_path: Option<&str>, locator: Option<&str>, name: Option<&str>, resolve_parameters: Option<bool>, log_build_usage: Option<bool>) -> Result<(), Error<GetZippedFileOfBuildError>> {

    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/app/rest/builds/{buildLocator}/artifacts/archived{path}", configuration.base_path, path=crate::apis::urlencode(path), buildLocator=crate::apis::urlencode(build_locator));
    let mut local_var_req_builder = local_var_client.get(local_var_uri_str.as_str());

    if let Some(ref local_var_str) = base_path {
        local_var_req_builder = local_var_req_builder.query(&[("basePath", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = locator {
        local_var_req_builder = local_var_req_builder.query(&[("locator", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = name {
        local_var_req_builder = local_var_req_builder.query(&[("name", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = resolve_parameters {
        local_var_req_builder = local_var_req_builder.query(&[("resolveParameters", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = log_build_usage {
        local_var_req_builder = local_var_req_builder.query(&[("logBuildUsage", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<GetZippedFileOfBuildError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn mark_build_as_running(configuration: &configuration::Configuration, build_locator: &str, fields: Option<&str>, body: Option<&str>) -> Result<crate::models::Build, Error<MarkBuildAsRunningError>> {

    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/app/rest/builds/{buildLocator}/runningData", configuration.base_path, buildLocator=crate::apis::urlencode(build_locator));
    let mut local_var_req_builder = local_var_client.put(local_var_uri_str.as_str());

    if let Some(ref local_var_str) = fields {
        local_var_req_builder = local_var_req_builder.query(&[("fields", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.json(&body);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<MarkBuildAsRunningError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn pin_multiple_builds(configuration: &configuration::Configuration, build_locator: &str, fields: Option<&str>, body: Option<crate::models::PinInfo>) -> Result<crate::models::MultipleOperationResult, Error<PinMultipleBuildsError>> {

    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/app/rest/builds/multiple/{buildLocator}/pinInfo", configuration.base_path, buildLocator=crate::apis::urlencode(build_locator));
    let mut local_var_req_builder = local_var_client.put(local_var_uri_str.as_str());

    if let Some(ref local_var_str) = fields {
        local_var_req_builder = local_var_req_builder.query(&[("fields", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.json(&body);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<PinMultipleBuildsError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn remove_multiple_build_tags(configuration: &configuration::Configuration, build_locator: &str, fields: Option<&str>, body: Option<crate::models::Tags>) -> Result<crate::models::MultipleOperationResult, Error<RemoveMultipleBuildTagsError>> {

    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/app/rest/builds/multiple/{buildLocator}/tags", configuration.base_path, buildLocator=crate::apis::urlencode(build_locator));
    let mut local_var_req_builder = local_var_client.delete(local_var_uri_str.as_str());

    if let Some(ref local_var_str) = fields {
        local_var_req_builder = local_var_req_builder.query(&[("fields", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.json(&body);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<RemoveMultipleBuildTagsError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn reset_build_finish_properties(configuration: &configuration::Configuration, build_locator: &str) -> Result<(), Error<ResetBuildFinishPropertiesError>> {

    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/app/rest/builds/{buildLocator}/caches/finishProperties", configuration.base_path, buildLocator=crate::apis::urlencode(build_locator));
    let mut local_var_req_builder = local_var_client.delete(local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<ResetBuildFinishPropertiesError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn set_build_comment(configuration: &configuration::Configuration, build_locator: &str, body: Option<&str>) -> Result<(), Error<SetBuildCommentError>> {

    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/app/rest/builds/{buildLocator}/comment", configuration.base_path, buildLocator=crate::apis::urlencode(build_locator));
    let mut local_var_req_builder = local_var_client.put(local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.json(&body);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<SetBuildCommentError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn set_build_finish_date(configuration: &configuration::Configuration, build_locator: &str, body: Option<&str>) -> Result<String, Error<SetBuildFinishDateError>> {

    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/app/rest/builds/{buildLocator}/finishDate", configuration.base_path, buildLocator=crate::apis::urlencode(build_locator));
    let mut local_var_req_builder = local_var_client.put(local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.json(&body);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<SetBuildFinishDateError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn set_build_number(configuration: &configuration::Configuration, build_locator: &str, body: Option<&str>) -> Result<String, Error<SetBuildNumberError>> {

    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/app/rest/builds/{buildLocator}/number", configuration.base_path, buildLocator=crate::apis::urlencode(build_locator));
    let mut local_var_req_builder = local_var_client.put(local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.json(&body);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<SetBuildNumberError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn set_build_pin_info(configuration: &configuration::Configuration, build_locator: &str, fields: Option<&str>, body: Option<crate::models::PinInfo>) -> Result<crate::models::PinInfo, Error<SetBuildPinInfoError>> {

    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/app/rest/builds/{buildLocator}/pinInfo", configuration.base_path, buildLocator=crate::apis::urlencode(build_locator));
    let mut local_var_req_builder = local_var_client.put(local_var_uri_str.as_str());

    if let Some(ref local_var_str) = fields {
        local_var_req_builder = local_var_req_builder.query(&[("fields", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.json(&body);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<SetBuildPinInfoError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn set_build_status_text(configuration: &configuration::Configuration, build_locator: &str, body: Option<&str>) -> Result<String, Error<SetBuildStatusTextError>> {

    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/app/rest/builds/{buildLocator}/statusText", configuration.base_path, buildLocator=crate::apis::urlencode(build_locator));
    let mut local_var_req_builder = local_var_client.put(local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.json(&body);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<SetBuildStatusTextError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn set_build_tags(configuration: &configuration::Configuration, build_locator: &str, locator: Option<&str>, fields: Option<&str>, body: Option<crate::models::Tags>) -> Result<crate::models::Tags, Error<SetBuildTagsError>> {

    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/app/rest/builds/{buildLocator}/tags", configuration.base_path, buildLocator=crate::apis::urlencode(build_locator));
    let mut local_var_req_builder = local_var_client.put(local_var_uri_str.as_str());

    if let Some(ref local_var_str) = locator {
        local_var_req_builder = local_var_req_builder.query(&[("locator", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = fields {
        local_var_req_builder = local_var_req_builder.query(&[("fields", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.json(&body);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<SetBuildTagsError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn set_finished_time(configuration: &configuration::Configuration, build_locator: &str) -> Result<String, Error<SetFinishedTimeError>> {

    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/app/rest/builds/{buildLocator}/finish", configuration.base_path, buildLocator=crate::apis::urlencode(build_locator));
    let mut local_var_req_builder = local_var_client.put(local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<SetFinishedTimeError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn set_multiple_build_comments(configuration: &configuration::Configuration, build_locator: &str, fields: Option<&str>, body: Option<&str>) -> Result<crate::models::MultipleOperationResult, Error<SetMultipleBuildCommentsError>> {

    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/app/rest/builds/multiple/{buildLocator}/comment", configuration.base_path, buildLocator=crate::apis::urlencode(build_locator));
    let mut local_var_req_builder = local_var_client.put(local_var_uri_str.as_str());

    if let Some(ref local_var_str) = fields {
        local_var_req_builder = local_var_req_builder.query(&[("fields", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.json(&body);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<SetMultipleBuildCommentsError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

