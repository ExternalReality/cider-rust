/*
 * TeamCity REST API
 *
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 2018.1
 * 
 * Generated by: https://openapi-generator.tech
 */


use reqwest;

use crate::apis::ResponseContent;
use super::{Error, configuration};


/// struct for typed errors of method `delete_vcs_root_instance_field`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DeleteVcsRootInstanceFieldError {
    DefaultResponse(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `delete_vcs_root_instance_repository_state`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DeleteVcsRootInstanceRepositoryStateError {
    DefaultResponse(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `download_file`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DownloadFileError {
    DefaultResponse(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `get_all_vcs_root_instances`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetAllVcsRootInstancesError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `get_file_metadata`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetFileMetadataError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `get_files_list`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetFilesListError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `get_files_list_for_subpath`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetFilesListForSubpathError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `get_vcs_root_instance`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetVcsRootInstanceError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `get_vcs_root_instance_creation_date`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetVcsRootInstanceCreationDateError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `get_vcs_root_instance_field`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetVcsRootInstanceFieldError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `get_vcs_root_instance_properties`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetVcsRootInstancePropertiesError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `get_vcs_root_instance_repository_state`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetVcsRootInstanceRepositoryStateError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `get_zipped_file`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetZippedFileError {
    DefaultResponse(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `request_pending_changes_check`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum RequestPendingChangesCheckError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `set_vcs_root_instance_field`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum SetVcsRootInstanceFieldError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `set_vcs_root_instance_repository_state`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum SetVcsRootInstanceRepositoryStateError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `trigger_commit_hook_notification`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum TriggerCommitHookNotificationError {
    DefaultResponse(),
    UnknownValue(serde_json::Value),
}


pub async fn delete_vcs_root_instance_field(configuration: &configuration::Configuration, vcs_root_instance_locator: &str, field: &str) -> Result<(), Error<DeleteVcsRootInstanceFieldError>> {

    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/app/rest/vcs-root-instances/{vcsRootInstanceLocator}/{field}", configuration.base_path, vcsRootInstanceLocator=crate::apis::urlencode(vcs_root_instance_locator), field=crate::apis::urlencode(field));
    let mut local_var_req_builder = local_var_client.delete(local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<DeleteVcsRootInstanceFieldError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn delete_vcs_root_instance_repository_state(configuration: &configuration::Configuration, vcs_root_instance_locator: &str) -> Result<(), Error<DeleteVcsRootInstanceRepositoryStateError>> {

    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/app/rest/vcs-root-instances/{vcsRootInstanceLocator}/repositoryState", configuration.base_path, vcsRootInstanceLocator=crate::apis::urlencode(vcs_root_instance_locator));
    let mut local_var_req_builder = local_var_client.delete(local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<DeleteVcsRootInstanceRepositoryStateError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn download_file(configuration: &configuration::Configuration, path: &str, vcs_root_instance_locator: &str) -> Result<(), Error<DownloadFileError>> {

    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/app/rest/vcs-root-instances/{vcsRootInstanceLocator}/files/latest/files{path}", configuration.base_path, path=crate::apis::urlencode(path), vcsRootInstanceLocator=crate::apis::urlencode(vcs_root_instance_locator));
    let mut local_var_req_builder = local_var_client.get(local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<DownloadFileError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn get_all_vcs_root_instances(configuration: &configuration::Configuration, locator: Option<&str>, fields: Option<&str>) -> Result<crate::models::VcsRootInstances, Error<GetAllVcsRootInstancesError>> {

    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/app/rest/vcs-root-instances", configuration.base_path);
    let mut local_var_req_builder = local_var_client.get(local_var_uri_str.as_str());

    if let Some(ref local_var_str) = locator {
        local_var_req_builder = local_var_req_builder.query(&[("locator", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = fields {
        local_var_req_builder = local_var_req_builder.query(&[("fields", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<GetAllVcsRootInstancesError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn get_file_metadata(configuration: &configuration::Configuration, path: &str, vcs_root_instance_locator: &str, fields: Option<&str>) -> Result<std::path::PathBuf, Error<GetFileMetadataError>> {

    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/app/rest/vcs-root-instances/{vcsRootInstanceLocator}/files/latest/metadata{path}", configuration.base_path, path=crate::apis::urlencode(path), vcsRootInstanceLocator=crate::apis::urlencode(vcs_root_instance_locator));
    let mut local_var_req_builder = local_var_client.get(local_var_uri_str.as_str());

    if let Some(ref local_var_str) = fields {
        local_var_req_builder = local_var_req_builder.query(&[("fields", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<GetFileMetadataError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn get_files_list(configuration: &configuration::Configuration, vcs_root_instance_locator: &str, base_path: Option<&str>, locator: Option<&str>, fields: Option<&str>) -> Result<crate::models::Files, Error<GetFilesListError>> {

    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/app/rest/vcs-root-instances/{vcsRootInstanceLocator}/files/latest", configuration.base_path, vcsRootInstanceLocator=crate::apis::urlencode(vcs_root_instance_locator));
    let mut local_var_req_builder = local_var_client.get(local_var_uri_str.as_str());

    if let Some(ref local_var_str) = base_path {
        local_var_req_builder = local_var_req_builder.query(&[("basePath", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = locator {
        local_var_req_builder = local_var_req_builder.query(&[("locator", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = fields {
        local_var_req_builder = local_var_req_builder.query(&[("fields", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<GetFilesListError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn get_files_list_for_subpath(configuration: &configuration::Configuration, path: &str, vcs_root_instance_locator: &str, base_path: Option<&str>, locator: Option<&str>, fields: Option<&str>) -> Result<crate::models::Files, Error<GetFilesListForSubpathError>> {

    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/app/rest/vcs-root-instances/{vcsRootInstanceLocator}/files/latest/{path}", configuration.base_path, path=crate::apis::urlencode(path), vcsRootInstanceLocator=crate::apis::urlencode(vcs_root_instance_locator));
    let mut local_var_req_builder = local_var_client.get(local_var_uri_str.as_str());

    if let Some(ref local_var_str) = base_path {
        local_var_req_builder = local_var_req_builder.query(&[("basePath", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = locator {
        local_var_req_builder = local_var_req_builder.query(&[("locator", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = fields {
        local_var_req_builder = local_var_req_builder.query(&[("fields", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<GetFilesListForSubpathError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn get_vcs_root_instance(configuration: &configuration::Configuration, vcs_root_instance_locator: &str, fields: Option<&str>) -> Result<crate::models::VcsRootInstance, Error<GetVcsRootInstanceError>> {

    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/app/rest/vcs-root-instances/{vcsRootInstanceLocator}", configuration.base_path, vcsRootInstanceLocator=crate::apis::urlencode(vcs_root_instance_locator));
    let mut local_var_req_builder = local_var_client.get(local_var_uri_str.as_str());

    if let Some(ref local_var_str) = fields {
        local_var_req_builder = local_var_req_builder.query(&[("fields", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<GetVcsRootInstanceError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn get_vcs_root_instance_creation_date(configuration: &configuration::Configuration, vcs_root_instance_locator: &str) -> Result<String, Error<GetVcsRootInstanceCreationDateError>> {

    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/app/rest/vcs-root-instances/{vcsRootInstanceLocator}/repositoryState/creationDate", configuration.base_path, vcsRootInstanceLocator=crate::apis::urlencode(vcs_root_instance_locator));
    let mut local_var_req_builder = local_var_client.get(local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<GetVcsRootInstanceCreationDateError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn get_vcs_root_instance_field(configuration: &configuration::Configuration, vcs_root_instance_locator: &str, field: &str) -> Result<String, Error<GetVcsRootInstanceFieldError>> {

    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/app/rest/vcs-root-instances/{vcsRootInstanceLocator}/{field}", configuration.base_path, vcsRootInstanceLocator=crate::apis::urlencode(vcs_root_instance_locator), field=crate::apis::urlencode(field));
    let mut local_var_req_builder = local_var_client.get(local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<GetVcsRootInstanceFieldError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn get_vcs_root_instance_properties(configuration: &configuration::Configuration, vcs_root_instance_locator: &str, fields: Option<&str>) -> Result<crate::models::Properties, Error<GetVcsRootInstancePropertiesError>> {

    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/app/rest/vcs-root-instances/{vcsRootInstanceLocator}/properties", configuration.base_path, vcsRootInstanceLocator=crate::apis::urlencode(vcs_root_instance_locator));
    let mut local_var_req_builder = local_var_client.get(local_var_uri_str.as_str());

    if let Some(ref local_var_str) = fields {
        local_var_req_builder = local_var_req_builder.query(&[("fields", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<GetVcsRootInstancePropertiesError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn get_vcs_root_instance_repository_state(configuration: &configuration::Configuration, vcs_root_instance_locator: &str, fields: Option<&str>) -> Result<crate::models::Entries, Error<GetVcsRootInstanceRepositoryStateError>> {

    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/app/rest/vcs-root-instances/{vcsRootInstanceLocator}/repositoryState", configuration.base_path, vcsRootInstanceLocator=crate::apis::urlencode(vcs_root_instance_locator));
    let mut local_var_req_builder = local_var_client.get(local_var_uri_str.as_str());

    if let Some(ref local_var_str) = fields {
        local_var_req_builder = local_var_req_builder.query(&[("fields", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<GetVcsRootInstanceRepositoryStateError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn get_zipped_file(configuration: &configuration::Configuration, path: &str, vcs_root_instance_locator: &str, base_path: Option<&str>, locator: Option<&str>, name: Option<&str>) -> Result<(), Error<GetZippedFileError>> {

    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/app/rest/vcs-root-instances/{vcsRootInstanceLocator}/files/latest/archived{path}", configuration.base_path, path=crate::apis::urlencode(path), vcsRootInstanceLocator=crate::apis::urlencode(vcs_root_instance_locator));
    let mut local_var_req_builder = local_var_client.get(local_var_uri_str.as_str());

    if let Some(ref local_var_str) = base_path {
        local_var_req_builder = local_var_req_builder.query(&[("basePath", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = locator {
        local_var_req_builder = local_var_req_builder.query(&[("locator", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = name {
        local_var_req_builder = local_var_req_builder.query(&[("name", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<GetZippedFileError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn request_pending_changes_check(configuration: &configuration::Configuration, locator: Option<&str>, requestor: Option<&str>, fields: Option<&str>) -> Result<crate::models::VcsRootInstances, Error<RequestPendingChangesCheckError>> {

    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/app/rest/vcs-root-instances/checkingForChangesQueue", configuration.base_path);
    let mut local_var_req_builder = local_var_client.post(local_var_uri_str.as_str());

    if let Some(ref local_var_str) = locator {
        local_var_req_builder = local_var_req_builder.query(&[("locator", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = requestor {
        local_var_req_builder = local_var_req_builder.query(&[("requestor", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = fields {
        local_var_req_builder = local_var_req_builder.query(&[("fields", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<RequestPendingChangesCheckError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn set_vcs_root_instance_field(configuration: &configuration::Configuration, vcs_root_instance_locator: &str, field: &str, body: Option<&str>) -> Result<String, Error<SetVcsRootInstanceFieldError>> {

    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/app/rest/vcs-root-instances/{vcsRootInstanceLocator}/{field}", configuration.base_path, vcsRootInstanceLocator=crate::apis::urlencode(vcs_root_instance_locator), field=crate::apis::urlencode(field));
    let mut local_var_req_builder = local_var_client.put(local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.json(&body);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<SetVcsRootInstanceFieldError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn set_vcs_root_instance_repository_state(configuration: &configuration::Configuration, vcs_root_instance_locator: &str, fields: Option<&str>, body: Option<crate::models::Entries>) -> Result<crate::models::Entries, Error<SetVcsRootInstanceRepositoryStateError>> {

    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/app/rest/vcs-root-instances/{vcsRootInstanceLocator}/repositoryState", configuration.base_path, vcsRootInstanceLocator=crate::apis::urlencode(vcs_root_instance_locator));
    let mut local_var_req_builder = local_var_client.put(local_var_uri_str.as_str());

    if let Some(ref local_var_str) = fields {
        local_var_req_builder = local_var_req_builder.query(&[("fields", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.json(&body);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<SetVcsRootInstanceRepositoryStateError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn trigger_commit_hook_notification(configuration: &configuration::Configuration, locator: Option<&str>, ok_on_nothing_found: Option<bool>) -> Result<(), Error<TriggerCommitHookNotificationError>> {

    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/app/rest/vcs-root-instances/commitHookNotification", configuration.base_path);
    let mut local_var_req_builder = local_var_client.post(local_var_uri_str.as_str());

    if let Some(ref local_var_str) = locator {
        local_var_req_builder = local_var_req_builder.query(&[("locator", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = ok_on_nothing_found {
        local_var_req_builder = local_var_req_builder.query(&[("okOnNothingFound", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<TriggerCommitHookNotificationError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

